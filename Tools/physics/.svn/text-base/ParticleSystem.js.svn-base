/**
* ParticleSystem
* @constructor
*/
function ParticleSystem(k, damp){
	this.forcesMatrix=[];
	this.forcesArray=[];
	this.nNodes=0;
	this.repulsorsArray=[];
	this.k=k?k:0.08;
	this.damp=damp?damp:0.7;
	
}
	/*
		public function setMaxRepulsorCalculations(value:int=1000):void
		{
			maxRepulsorCalculations=value;
		}
		public function enableRepulsorsOptimization(value:Boolean=true):void
		{
			repulsorsOptimization=value;
		}
		*/
		/** adds a Node to the particle system**/
ParticleSystem.prototype.addNode=function(node){
			var nodeRequest=this.requestNode(node); //verify if node was already added
			var nodePhysics=nodeRequest[0];
			var index=nodeRequest[1];
			if(nodePhysics==null){
				if(this.forcesMatrix[index]==null){
					this.forcesMatrix[index]=[]
				}
				/*if(nodePhysics is PhysicsForce){
					throw new Error("")
				}
				*/
				this.forcesMatrix[index][index]=node;
				if(index+1>this.nNodes){
					this.nNodes++;
				}
				//traceForcesMatrix()
			}
			//trace(node, "++++>>", index);
			return [node, index];
		}
/*TODO: fix this method
ParticleSystem.prototype.fillRepulsorMatrix=function(k, length){
	//fillForcesMatrix(Repulsor, k, length);
	this.repulsorArray=new Array();
	var nodeii;
	var i;
	var j;
	for(i=0; i<this.nNodes; i++){
		//trace("i, nodeii:", i, nodeii);
		//trace("forcesMatrix[i][i]", forcesMatrix[i][i]);
		nodeii = this.forcesMatrix[i][i];
		if(nodeii==null){
			for(j=0; j<i; j++){
				this.forcesMatrix[j][i]=null;
			}
			this.forcesMatrix[i]=[];
		}else{
			for(j=i+1; j<this.nNodes; j++){
				if(this.forcesMatrix[j][j]==null || this.forcesMatrix[j][j]==""){
					this.forcesMatrix[i][j]="";
				}else if(this.forcesMatrix[i][j] == null || this.forcesMatrix[i][j] ==""){
					var force;
					if(nodeii!=null && this.forcesMatrix[j][j]!="" && this.forcesMatrix[j][j]!=null){
						force=new Repulsor(nodeii, this.forcesMatrix[j][j], k, length);
						this.repulsorsArray.push(force);
						this.forcesMatrix[i][j]=force; //was commented for optimizer!
					}
				}
			}
		}
	}
}
*/
ParticleSystem.prototype.fillSpringMatrix=function(k, length){
	this.fillForcesMatrix("Spring", k, length);
}
		
ParticleSystem.prototype.clearForcesMatrix=function(){
	var i;
	var j;
	for(i=0; i<this.nNodes; i++){
		if(this.forcesMatrix[i][i]==null || this.forcesMatrix[i][i]==""){
			for(j=0; j<i; j++){
				this.forcesMatrix[j][i]=null;
			}
			this.forcesMatrix[i]=[];
		}
	}
}
ParticleSystem.prototype.fillForcesMatrix=function(forceType){
	var i;
	var j;
	for(i=0; i<this.nNodes; i++){
		if(this.forcesMatrix[i][i]==null || this.forcesMatrix[i][i]==""){
			for(j=0; j<i; j++){
				this.forcesMatrix[j][i]=null;
			}
			this.forcesMatrix[i]=[];
		}else{
			for(j=i+1; j<this.nNodes; j++){
				if(this.forcesMatrix[j][j]==null || this.forcesMatrix[j][j]==""){
					this.forcesMatrix[i][j]="";
				}else if(this.forcesMatrix[i][j] == null || this.forcesMatrix[i][j] ==""){
					var force;
					if(this.forcesMatrix[i][i]!=null && this.forcesMatrix[i][i]!="" && this.forcesMatrix[j][j]!="" && this.forcesMatrix[j][j]!=null){
						switch (arguments.length) {
							case 1: force = new window[forceType](this.forcesMatrix[i][i], this.forcesMatrix[j][j]); break;
							case 2: force = new window[forceType](this.forcesMatrix[i][i], this.forcesMatrix[j][j], arguments[1]);break;
							case 3: force = new window[forceType](this.forcesMatrix[i][i], this.forcesMatrix[j][j], arguments[1], arguments[2]);break;
							case 4: force = new window[forceType](this.forcesMatrix[i][i], this.forcesMatrix[j][j], arguments[1], arguments[2], arguments[3]);break;
							case 5: force = new window[forceType](this.forcesMatrix[i][i], this.forcesMatrix[j][j], arguments[1], arguments[2], arguments[3], arguments[4]);break;
						}
						this.forcesMatrix[i][j]=force;
						this.forcesArray.push(force);
					}
				}
			}
		}
	}
}
ParticleSystem.prototype.traceForcesMatrix=function(){
			var i;
			var j;
			for (i=0; i<this.nNodes; i++){
				if(this.forcesMatrix[i]==null){
					this.forcesMatrix[i]=[];
				}
				var s="";
				for (j=0; j<this.nNodes; j++){
					if(this.forcesMatrix[i][j]==null){
						this.forcesMatrix[i][j]=[];
					}
					s+=" |"+this.forcesMatrix[i][j]+"| ";
				}
				console.log("			|"+s+"|");
			}
			console.log("\n");
		}
		
		/**
		 * Removes Node and related forces from particle system
		 * 
		 * @param node Node to remove from particleSystem
		 *  
		 */
ParticleSystem.prototype.removeNode=function(node){
	var i;
	var index=this.nNodes;
	for(i=0; i<this.nNodes; i++){
		if(this.forcesMatrix[i][i]==node){
			var j;
			for(j=i+1; j<this.nNodes; j++){
				this.forcesMatrix[i][j]=null;
			}
			this.forcesMatrix[i][i]=null;
		}
	}
	for(i=0; i<this.forcesArray.length; i++){
		if(this.forcesArray[i].node0==node || this.forcesArray[i].node1==node){
			this.forcesArray.splice(i, 1);
			i--;
		}
	}
	this.clearForcesMatrix();
	//traceForcesMatrix();
}

		//waiting for possibility of adding events...
		/*private function onNodeRemoved(e:Event):void{
		removeNodePhysics(NodePhysics(e.currentTarget))
		clearForcesMatrix()
		}*/
		
		/*protected function removeNodePhysics(node:Node):void{
			
		}*/
		
ParticleSystem.prototype.addSpring=function(nodeP0, nodeP1, k, d) {
	if(nodeP0==nodeP1) return;
	this.addForce(nodeP0, nodeP1, "Spring", k?k:1, d?d:0);
}
ParticleSystem.prototype.addForce=function(nodeP0, nodeP1, forceType){
	//
	//console.log("adding force:", forceType);
	var preq0=this.addNode(nodeP0);
	var pNode0=preq0[0];
	var pIndex0=preq0[1];
	pNode0.x+=((Math.random()-0.5)*0.00000001);
	pNode0.y+=((Math.random()-0.5)*0.00000001);
	var preq1=this.addNode(nodeP1);
	var pNode1=preq1[0];
	var pIndex1=preq1[1];
	pNode1.x+=((Math.random()-0.5)*0.00000001);
	pNode1.y+=((Math.random()-0.5)*0.00000001);
	
	if(pIndex0<pIndex1){
		var aPhysics=[pNode0, pNode1];
		var aIndex=[pIndex0, pIndex1];
	}else{
		aPhysics=[pNode1, pNode0];
		aIndex=[pIndex1, pIndex0];
	}
	var force;
	//console.log(arguments.length, arguments);
	switch (arguments.length) {
		case 2: force = new window[forceType](aPhysics[0], aPhysics[1]); break;
		case 3: force = new window[forceType](aPhysics[0], aPhysics[1], arguments[3]);break;
		case 4: force = new window[forceType](aPhysics[0], aPhysics[1], arguments[3], arguments[4]);break;
		case 5: force = new window[forceType](aPhysics[0], aPhysics[1], arguments[3], arguments[4], arguments[5]);break;
		case 6: force = new window[forceType](aPhysics[0], aPhysics[1], arguments[3], arguments[4], arguments[5], arguments[6]);break;
	}
	if(this.forcesMatrix[aIndex[0]]==null){
		this.forcesMatrix[aIndex[0]]=[]
	}
	
	this.forcesMatrix[aIndex[0]][aIndex[1]]=force;
	//console.log("aIndex[0], aIndex[1] force", aIndex[0], aIndex[1], force);
	this.forcesArray.push(force);
	//traceForcesMatrix()
	
}
		
ParticleSystem.prototype.removeForceFromNodes=function(node0, node1) { //returns boolean
	var i;
	var preq0=this.requestNode(node0);
	var pNode0=preq0[0];
	if(pNode0==null){
		return 'false';
	}
	var pIndex0=preq0[1];
	var preq1=this.requestNode(node1);
	var pNode1=preq1[0];
	if(pNode1==null) return 'false';
	var pIndex1=preq1[1];
	if(pIndex0<pIndex1){
		this.forcesMatrix[pIndex0][pIndex1]=null;
	}else{
		this.forcesMatrix[pIndex1][pIndex0]=null;
	}
	
	for(i=0; i<this.forcesArray.length; i++)
	{
		if((this.forcesArray[i].node0==node0 && this.forcesArray[i].node1==node1) || (this.forcesArray[i].node0==node1 && this.forcesArray[i].node1==node0))
		{
			this.forcesArray.splice(i, 1);
			i--;
		}
	}
	this.clearForcesMatrix();
	return true;
}
		
		//
ParticleSystem.prototype.calculateParticles=function(){
	var i;
	//calculate forces:
	var node;
	for(i=0; i<this.nNodes; i++){
		node = this.forcesMatrix[i][i];
		if(node!=null){
			node.ax=0;
			node.ay=0;
			node.az=0;
		}
	}
	for(i=0; i<this.forcesArray.length; i++){
		this.forcesArray[i].calculate();
	}
	
	//calculate fillRepulsors:
	var repulsor;
	var node0;
	var node1;
	var d;

	//TODO: add repulsorsOptimization:
	/*
	if(repulsorsOptimization && repulsorArray.length > 0){
		for(i=nE; i<nE+maxRepulsorCalculations; i++)
		{
			repulsor=repulsorArray[i%repulsorArray.length];
			node0 = repulsor.node0;
			node1 = repulsor.node1;
			d = Math.sqrt(Math.pow(node0.position.x-node1.position.x,2)+Math.pow(node0.position.y-node1.position.y,2)+Math.pow(node0.position.z-node1.position.z, 2));
			if(!repulsor.isPreActive && d<(repulsor.length*PREACTIVE_FACTOR)){
				preActiveRepulsorArray.push(repulsor);
				repulsor.isPreActive=true;
			}
		}
		nE=(nE+maxRepulsorCalculations)%repulsorArray.length;
		nPreActiveRepulsors = preActiveRepulsorArray.length;
		//
		//trace("nPreActiveRepulsors:", nPreActiveRepulsors);
		for(i=0; i<nPreActiveRepulsors; i++)
		{
			var status:int=preActiveRepulsorArray[i].preActiveCalculate()
			if(status==1){
				preActiveRepulsorArray.splice(i,1);
				i--;
				nPreActiveRepulsors--;
			}
		}
	}else{
		for(i=0; i<repulsorArray.length; i++)
		{
			repulsor=repulsorArray[i].calculate();
		}
	}
	*/
	//////
	
	for(i=0; i<this.nNodes; i++){
		node = this.forcesMatrix[i][i];
		if(node!=null){
			this.assignPositions(node);
		}
	}
}


		
ParticleSystem.prototype.assignPositions=function(node){
	
	node.vx+=node.ax;
	node.vy+=node.ay;
	node.vz+=node.az;
	node.vx*=this.damp;
	node.vy*=this.damp;
	node.vz*=this.damp;
	//console.log(node.label+" velocities:", node.vx, node.vy, node.vz);
	node.x+=node.vx;
	node.y+=node.vy;
	node.z+=node.vz;
	//console.log(node.label+" positions:", node.x, node.y, node.z);
}
		/*
		public function getMaxSpeed():Number{
			var node:Node;
			var maxSpeed2:Number=0;
			for(var i:uint=0; i<nNodes; i++){
				if(forcesMatrix[i][i]!=null){
					node = forcesMatrix[i][i];
					maxSpeed2 = Math.max(maxSpeed2, Math.pow(node.physicProperties.vx, 2)+Math.pow(node.physicProperties.vy, 2)+Math.pow(node.physicProperties.vz, 2));
				} else {
					//trace("[!] ParticleSystem / something went wrong, forcesMatrix[i][i]==null, i=", i, " / nNodes=", nNodes);
				}
			}
			return Math.sqrt(maxSpeed2);
		}
	*/
		
		/**
		 * deprectaed 
		 * 
		 */
		/*
		public function project():void
		{
			trace("ParticleSystem.project is a deprectaed method. Instead use Node.toPosition, but even better use Space2D to create a controlled projection")
			var i:uint;
			
			for(i=0; i<nNodes; i++){
				if(forcesMatrix[i][i]!=null && forcesMatrix[i][i]!=""){
					var node:Node=forcesMatrix[i][i];
					node.x=node.position.x;
					node.y=node.position.y;
					node.z=node.position.z;
				}
			}
		}
		*/
		//
		/** Returns an Array with an existant physics node, or empty index to create the PhysicsNode**/
ParticleSystem.prototype.requestNode=function(node){
	var i;
	var index=this.nNodes;
	for(i=this.nNodes-1; i>=0; i--){
		var f=this.forcesMatrix[i][i];
		if(this.forcesMatrix[i][i]==null || this.forcesMatrix[i][i]==""){
			index=i;
		}else if(node == this.forcesMatrix[i][i]){
			//trace(forcesMatrix[i], i)
			return [this.forcesMatrix[i][i], i];
		}
	}
	if(this.forcesMatrix[i]==null){
		this.forcesMatrix[i]=[];
		//nNodes++; // [!]  ADICIONADO POR SANTIAGO, CORRIGIENDO UN POSIBLE ERROR
	}
	return [null, index];
}