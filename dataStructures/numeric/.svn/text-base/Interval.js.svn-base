Interval.prototype = new DataModel();
Interval.prototype.constructor=Interval;

/**
* Interval
* @param {Number} Interval's minimum value
* * @param {Number} Interval's maximum value
* @constructor
*/
function Interval (min, max) {
	DataModel.apply(this, arguments);
    this.min=min;
    this.max=max;
    this.type="Interval";
}
Interval.prototype.getMin=function(){
	return this.min;
}
Interval.prototype.getMax=function(){
	return this.max;
}
Interval.prototype.getAmplitude=function(){
	return Math.abs(this.max-this.min);
}
Interval.prototype.getSignedAmplitude=function(){
	return this.max-this.min;
}
Interval.prototype.getMiddle=function(){
	return (this.max+this.min)*0.5;
}
Interval.prototype.getSign=function(){
	if(this.min==this.max) return 0;
	return this.getAmplitude()/this.getSignedAmplitude();
}
/**
* invert the interval  
* 
*/ 
		
Interval.prototype.invert=function(){
	var swap=this.min;
	this.min=this.max;
	this.max=swap;
}

/**
 * return a value in interval range
 * 0 -> min
 * 1 -> max
 * @param value between 0 and 1 (to obtain values between min and max)
 * @return 
 * 
 */
Interval.prototype.getInterpolatedValue=function(value){
	if(value<0 && value >1) return null;
	return value*this.getSignedAmplitude() + this.min;
}
		
Interval.prototype.getInverseInterpolatedValue=function(value){
	if(this.min==value) return 0;
	return (value-this.min)/this.getSignedAmplitude();
}
Interval.prototype.getInterpolatedValues=function(numberList){
	var newNumberList = new Array();
	var nElements=numberList.length;
	for(var i=0; i<nElements; i++){
		newNumberList.push(this.getInterpolatedValue(numberList[i]));
	}
	return newNumberList;
}
Interval.prototype.getInverseInterpolatedValues=function(numberList){
	var newNumberList = new Array();
	var nElements=numberList.length;
	for(var i=0; i<nElements; i++){
		newNumberList.push(this.getInverseInterpolatedValue(numberList[i]));
	}
	return newNumberList;
}
/**
* create a new interval with the same proporties values 
* @return 
* 
*/
Interval.prototype.clone=function(){
	var newInterval = new Interval(this.min, this.max);
	newInterval.name = name;
	return newInterval;
}
		
/**
* indicate wether a number is included in the interval 
* @param value
* @return 
* 
*/
Interval.prototype.belongsToInterval=function(value){
	if(this.max>this.min) return value>=this.min && value<=this.max;
	return value>=this.max && value<=this.min;
}

/**
 * create a new interval with the same proporties values 
 * @return 
 * 
 */

Interval.prototype.toString=function(){
	return "Interval[min:"+this.min+"| max:"+this.max+"| amplitude:"+this.getAmplitude()+"]";
}
		
//TODO: REQUIRES POINT3D;
/**
 * calculates a subdivision of the interval
 * usfeul for axis marks
 * delta: (stored in x) indicate the separation between subdivisions
 * first unitie: (stored in y)
 * last unitie: (stored in z)
 * @param deepUnits
 * @return  delta, first unitie and last unitie stored in x, y, z respectively
 * 
 */
/*
Interval.prototype.getRules(deepUnits=1):Point3D{
			var tenPow:int = Math.floor(Math.log(getAmplitude())/Math.log(10));
			var unit:uint = Math.floor(getAmplitude()/Math.pow(10,tenPow));
			var delta:Number = Math.pow(10, tenPow-deepUnits);
			var firstUnitie:Number = Math.floor(x/delta)*delta + delta;
			var lastUnitie:Number = Math.floor(y/delta)*delta;
			var nMarks:Number = Math.floor(getAmplitude()/delta);
			
			return new Point3D(delta, firstUnitie, lastUnitie);
		}
*/
	

		
