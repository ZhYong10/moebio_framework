Polygon2D.prototype = new List();
Polygon2D.prototype.constructor=Polygon2D;
/**
* Polygon2D â€“ A list of Points
* @constructor
*/
function Polygon2D(){
	var array=List.apply(this, arguments);
	array=Polygon2D.fromArray(array);
   	return array;
};
Polygon2D.fromArray=function(array){
	var result=List.fromArray(array);
	result.type="Polygon2D";
   	//assign methods to array:
   	result.addPoint=Polygon2D.prototype.addPoint;
   	result.removePoint=Polygon2D.prototype.removePoint;
   	result.removeNode=Polygon2D.prototype.removeNode;

	return result;
}


/**
* add a Point to Polygon2D
* @param {Point} point a Point to be added
*/
Polygon2D.prototype.addPoint=function(point){
  this.points.push(node);
};
/**
* remove a Point from Polygon2D
* @param {Point} point a Point to be removed
*/
Polygon2D.prototype.removePoint=function(point){
  this.removeElement(point);
};

Polygon2D.getCirclesDisposedInSpiral=function(weights, frame){
	var sortedCenters;
	var centers = new Polygon2D();
	var sortedRadius;
	var radius = new NumberList();
	//console.log(weights, weights.type)
	var sortArray = weights.sortNumericIndexed();
	//console.log("sortArray:", weights, sortArray);
	var maxWeight = 0;
	var nElements = weights.length;
	var i;
	var j;
	
	if(nElements==1){
		var table=new Table();
		var pointList=new Polygon2D();
		var point=new Point()
		pointList.push(point);
		table.push(pointList);
		var list=new List();
		list.push(1);
		table.push(list);
		return table;
	}
	maxWeight =weights.getMax();
	
	
	if(maxWeight==0) return null;
	
	var MIN_SPACE_BETWEEN_CIRCLES = 0.1;
	
	sortedRadius = new NumberList(Math.sqrt(weights[sortArray[0]]/maxWeight), Math.sqrt(weights[sortArray[1]]/maxWeight));
	sortedCenters = new Polygon2D(new Point(0,0), new Point(sortedRadius[0] + sortedRadius[1] + MIN_SPACE_BETWEEN_CIRCLES,0));
	//console.log("sortedCenters:", sortedCenters),
	centers[sortArray[0]] = sortedCenters[0];
	radius[sortArray[0]] = sortedRadius[0];
	
	centers[sortArray[1]] = sortedCenters[1];
	radius[sortArray[1]] = sortedRadius[1];
	console.log(centers);
	console.log(radius);
	var r;
	var rI;
	var angle = 0;
	
	var testPoint = new Point(0, 0);
	var externR = sortedCenters[1].x + sortedRadius[1];
	
	//var ACCUM_J:Number=0;
	
	for(i=2; i<nElements; i++){
		rI = Math.sqrt(weights[sortArray[i]]/maxWeight);
		//trace(i, "rI", rI);
		r = sortedRadius[0] + rI + MIN_SPACE_BETWEEN_CIRCLES;
		angle = i;
		
		for(j=0; j<100000; j++){
			testPoint.x = r*Math.cos(angle);
			testPoint.y = r*Math.sin(angle);
			
			r+=0.01;
			angle+=r*0.04;
			
			if(Polygon2D.testCircleAtPoint(testPoint, rI+MIN_SPACE_BETWEEN_CIRCLES, sortedCenters, sortedRadius) || j==99999){
				sortedCenters.push(new Point(testPoint.x, testPoint.y));
				sortedRadius.push(rI);
				centers[sortArray[i]] = sortedCenters[i];
				radius[sortArray[i]] = sortedRadius[i];
				externR = Math.max(externR, Math.sqrt(Math.pow(testPoint.x, 2)+Math.pow(testPoint.y, 2)) + rI);
				break;
			}
		}
		//ACCUM_J+=j
		
	}
	//trace("   packingCircles:ACCUM_J", ACCUM_J);
	//console.log("c:", centers);
	//console.log("r:", radius);
	var mulVal=1/externR;
	for(i=0; i<centers.length; i++){
		centers[i].x*=mulVal;
		centers[i].y*=mulVal;
	}
	for(i=0; i<radius.length; i++){
		radius[i]*=mulVal;
	}
	//centers = centers.multiply();
	//radius = radius.multiply(1/externR);
	//console.log("c2:", centers);
	//console.log("r2:", radius);
	
	return new Array(centers, radius);
}
Polygon2D.testCircleAtPoint=function(point, r, centers, radius){
	for(var i=1; centers[i]!=null; i++){
		if(Math.sqrt(Math.pow(centers[i].x-point.x, 2) + Math.pow(centers[i].y-point.y, 2)) < (radius[i] + r)){
			return false;
		}
	}
	return true;
}

Polygon2D.packingRectangles=function(weights, packingMode, rectangle){
	//TODO: implement param, whatever that is!!
	if(rectangle==null) rectangle = new Rectangle(0,0,1,1);
	packingMode=packingMode?packingMode:0;
	switch(packingMode){
		//0: quadrification
		//1: vertical
		//2: horizontal
		//3: continental quadrigram (Africa, Asia, Australasia, Europe, North America, South America)
		//4: europe quadrigram
		case 0:
			rectangleList = Polygon2D.squarified(rectangle, weights);
			//var indexes = weights.sortNumericIndexed();
			/*trace("indexes:", indexes);
			//rectangleList = OperatorsList.reverseList(OperatorsList.sortListByNumberList(rectangleList, new NumberList(indexes))) as RectangleList;
			rectangleList = OperatorsList.sortListByNumberList(rectangleList, new NumberList(indexes)) as RectangleList;*/
			return rectangleList;
		case 1:
			var minMax = weights.getMinMaxInterval();
			if(minMax.min<0){
				weights = weights.add(-minMax.min);
				minMax = new Interval(0, minMax.max-minMax.min);
			}
			 
			var sum = weights.sum();
			
			var rectangleList = new List();//RectangleList();
			var dY=rectangle.y;
			var h;
			var vFactor = rectangle.height/sum;
			var i;
			for(i=0; weights[i]!=null; i++){
				h = vFactor*weights[i];
				rectangleList.push(new Rectangle(rectangle.x, dY, rectangle.width, h));
				dY+=h;
			}
			return rectangleList;
		case 2:
			minMax = weights.getMinMaxInterval();
			if(minMax.min<0){
				weights = weights.add(-minMax.min);
				minMax = new Interval(0, minMax.max-minMax.min);
			}
			sum = weights.sum;
			
			rectangleList = new RectangleList();
			var dX=rectangle.x;
			var w;
			var hFactor = rectangle.width/sum;
			for(i=0; weights[i]!=null; i++){
				w = hFactor*weights[i];
				rectangleList.push(new Rectangle(dX, rectangle.y, w, rectangle.height));
				dX+=w;
			}
			return rectangleList;
			//var newNumberList:NumberList = OperatorsNumberList.accumulationNumberList(OperatorsNumberList.normalizeNumberListToInterval(weights, new Interval(weights.min, 1)));
		case 3:
			if(weights.length<6){
				
			} else if(weights.length==6){
				var rAfrica = new Rectangle(0.44,0.36,0.16,0.45);
				var rAsia = new Rectangle(0.6,0.15,0.3,0.3);
				var rAustralasia = new Rectangle(0.72,0.45,0.28,0.32);
				var rEurope = new Rectangle(0.38,0.04,0.22,0.32);
				
				var pivotEuroafrasia = new Point(0.6,0.36);
				rAfrica = expandRectangle(rAfrica, Math.sqrt(weights[0]), pivotEuroafrasia);
				rAsia = expandRectangle(rAsia, Math.sqrt(weights[1]), pivotEuroafrasia);
				rEurope = expandRectangle(rEurope, Math.sqrt(weights[3]), pivotEuroafrasia);
				
				rAustralasia.x = rAsia.x + rAsia.width*0.5;
				rAustralasia.y = rAsia.bottom;
				var pivotAustralasia = new Point(rAustralasia.x + rAustralasia.width*0.3, rAsia.bottom);
				rAustralasia = expandRectangle(rAustralasia, Math.sqrt(weights[2]), pivotAustralasia);
				rAustralasia.y+=rAustralasia.height*0.2;
				
				var pivotAmericas = new Point(0.26,0.36 + Math.max(rAfrica.height*0.3, rEurope.height*0.2));
				
				var rNorthAmerica = new Rectangle(0.1, pivotAmericas.y-0.4,0.2,0.4);
				var rSouthAmerica = new Rectangle(0.22, pivotAmericas.y,0.16,0.5);
				
				rNorthAmerica = expandRectangle(rNorthAmerica, Math.sqrt(weights[4]), pivotAmericas);
				rSouthAmerica = expandRectangle(rSouthAmerica, Math.sqrt(weights[5]), pivotAmericas);
				
				var separation = Math.max(rEurope.width, rAfrica.width, rSouthAmerica.right-pivotAmericas.x, rNorthAmerica.right-pivotAmericas.x)*0.2;
				var delta = Math.min(rEurope.x, rAfrica.x) - Math.max(rNorthAmerica.right, rSouthAmerica.right)-separation;
				
				rSouthAmerica.x+=delta;
				rNorthAmerica.x+=delta;
				
				return new List(rAfrica, rAsia, rAustralasia, rEurope, rNorthAmerica, rSouthAmerica); //RectangleList
				
			} else {
				
			}
		case 4:
			return europeQuadrigram(weights);
	}
	return null;
}
/**
* Squarified algorithm as described in (http://www.win.tue.nl/~vanwijk/stm.pdf)
* @param {Rectangle} bounds Rectangle
* @param {NumberList} list of weights
* @param {Boolean} weights are normalized
* @param {Boolean} weights are sorted
* 
* @return {List} a list of Rectangles
*/
Polygon2D.squarified=function(rectangle, weightList, isNormalizedWeights, isSortedWeights){//, funcionEvaluacionnWeights:Function=null):Array{
	isNormalizedWeights=isNormalizedWeights?isNormalizedWeights:false;
	isSortedWeights=isSortedWeights?isSortedWeights:false;
	if(isNormalizedWeights){
		var newWeightList = weightList;// new NumberList(arregloPesos);
	} else {
		newWeightList = weightList.normalizedSum();
	}
	/*trace();
	trace("rectangle:", rectangle);
	trace("arregloEstaNormalizado", arregloEstaNormalizado);
	trace("isSortedWeights", isSortedWeights);
	trace("arregloPesos:", arregloPesos);
	trace("nuevoArregloPesos:", nuevoArregloPesos);*/
	/*if(!arregloEstaNormalizado){
		TransformacionesArrayNumeros.normalizaArrayASuma(nuevoArregloPesos);
	}*/
	if(!isSortedWeights){
		var newPositions = newWeightList.sortNumericIndexedDescending();
		//trace("------------------------>>> quadrification | newPositions::", newPositions);
		newWeightList.sortNumericDescending();
		//trace("nuevoArregloPesos:", nuevoArregloPesos);
	}
	//console.log("newWeightList", newWeightList);
	var area =  rectangle.width*rectangle.height;
	var rectangleList=new List();//RectangleList;
	var freeRectangle = rectangle.clone();
	var subWeightList;
	var subRectangleList = new List();//RectangleList();
	var prevSubRectangleList;
	var proportion;
	var worstProportion;
	var index=0;
	var subArea;
	var freeSubRectangle = new Rectangle();
	var nWeights = weightList.length;
	var lastRectangle;
	var isColumn;
	if(nWeights>2){
		var i;
		var j;
		for(i=index; i<nWeights; i++){
			//console.log("  i", i);
			proportion = Number.MAX_VALUE;
			if(newWeightList[i]==0){
				rectangleList.push(new Rectangle(freeSubRectangle.x, freeSubRectangle.y, 0, 0));
			} else {
				for(j=1; j<nWeights; j++){ 
					subWeightList = NumberList.fromArray(newWeightList.slice(i, i+j));
					//console.log("subWeightList", i, j, subWeightList);
					prevSubRectangleList = subRectangleList.clone();
					//console.log("  prevSubRectangleList", prevSubRectangleList);
					//subArea = OperacionesArrayNumeros.sumatoria(subWeightList)*area;
					subArea = subWeightList.getSum()*area;
					//console.log("subArea", subArea);
					//trace("subArea", subArea);
					freeSubRectangle.x = freeRectangle.x;
					freeSubRectangle.y = freeRectangle.y;
					//console.log(".", freeRectangle, freeSubRectangle);
					if(freeRectangle.width>freeRectangle.height){ //column
						freeSubRectangle.width = subArea/freeRectangle.height;
						freeSubRectangle.height = freeRectangle.height;
						//trace("  column");
						column = true;
					} else { //fila
						freeSubRectangle.width = freeRectangle.width;
						freeSubRectangle.height = subArea/freeRectangle.width;
						column = false;
						//trace("  !column");
					}
					//trace("  freeSubRectangle", freeSubRectangle);
					//TransformacionesArrayNumeros.normalizaArrayASuma(subWeightList);
					subWeightList = subWeightList.normalizedSum();
					subRectangleList = Polygon2D.partitionRectangle(freeSubRectangle, subWeightList);
					worstProportion = Polygon2D.getHighestRatio(subRectangleList);
					if(proportion<=worstProportion){
						break;
					} else {
						proportion = worstProportion;
					}
				}
				
				if(prevSubRectangleList.length==0){
					rectangleList.push(freeRectangle.clone());
					if(rectangleList.length==nWeights){
						if(!isSortedWeights){
							var newRectagleList = new List();//RectangleList();
							for(i=0; rectangleList[i]!=null; i++){
								newRectagleList[newPositions[i]] = rectangleList[i];
							}
							return newRectagleList;
						}
						return rectangleList;
					}
					index++;
				} else {
					rectangleList = List.fromArray(rectangleList.concat(prevSubRectangleList));//RectangleList
					if(rectangleList.length==nWeights){
						if(!isSortedWeights){
							newRectagleList = new List();//RectangleList
							for(i=0; rectangleList[i]!=null; i++){
								newRectagleList[newPositions[i]] = rectangleList[i];
							}
							return newRectagleList;
						}
						return rectangleList;
					}
					index+=prevSubRectangleList.length;
					lastRectangle = prevSubRectangleList[prevSubRectangleList.length-1];
					if(freeRectangle.width>freeRectangle.height){
						freeRectangle.x = (lastRectangle.width + lastRectangle.x);
						freeRectangle.width-=lastRectangle.width;
					} else {
						freeRectangle.y = (lastRectangle.height+lastRectangle.y);
						freeRectangle.height -= lastRectangle.height;
					}
				}
				i=index-1;
			}
		}
	} else if(nWeights==2){
		subWeightList = newWeightList.clone();
		freeSubRectangle = rectangle.clone();
		rectangleList = Polygon2D.partitionRectangle(freeSubRectangle, subWeightList);
	} else {
		rectangleList[0] = rectangle.clone();
	}
	
	
	if(!isSortedWeights){
		newRectagleList = new List();//RectangleList
		for(i=0; rectangleList[i]!=null; i++){
			newRectagleList[newPositions[i]] = rectangleList[i];
		}
		return newRectagleList;
	}
	
	return rectangleList;
}

/**
* partitionRectangle 
* @param {Rectangle} bounds Rectangle
* @param {NumberList} normalizedWeight List
* 
* @return {List} a list of Rectangles
*/
Polygon2D.partitionRectangle=function(rectangle, normalizedWeightList){
	var area =  rectangle.width*rectangle.height;
	var rectangleList=new List();//RectangleList();
	var freeRectangle = rectangle.clone();
	//console.log("??", freeRectangle);
	var areai;
	var i;
	for(i=0; i<normalizedWeightList.length; i++){
		areai = normalizedWeightList[i]*area;
		if(rectangle.width>rectangle.height){
			rectangleList.push(new Rectangle(freeRectangle.x, freeRectangle.y, areai/freeRectangle.height, freeRectangle.height));
			freeRectangle.x+=areai/freeRectangle.height;
		} else {
			rectangleList.push(new Rectangle(freeRectangle.x, freeRectangle.y, freeRectangle.width, areai/freeRectangle.width));
			freeRectangle.y+=areai/freeRectangle.width;
		}
	}
	//trace("            rectangulo, listaRectangulos:", rectangulo, listaRectangulos);
	return rectangleList;
}

//TODO: should be in RectangleList:
/**
* returns the highest ratio from a list of Rectangles
* @param {List} rectangleList a Rectangle List
* 
* @return {Number} highestRatio
*/
Polygon2D.getHighestRatio=function(rectangleList){
			var highestRatio = 1;
			var rectangle;
			var i;
			for(i=0; i<rectangleList.length; i++){
				rectangle = rectangleList[i];
				highestRatio = Math.max(highestRatio, rectangle.getRatio() );
			}
			return highestRatio;
		}

		