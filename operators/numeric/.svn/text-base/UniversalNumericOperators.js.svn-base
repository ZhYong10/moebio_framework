/**
* Universal Numeric Operators
* @constructor
*/
function UniversalNumericOperators(){};
/** 
* receives n arguments and performs addition
*/

UniversalNumericOperators.addition=function(){
	var objectType;
	var result;
	var i;
	if(arguments.length<2){
		return result;
	}
	if(arguments.length==2){
		if(arguments[0].isOfType("Array") && arguments[1].isOfType("Array")){
			return UniversalNumericOperators.applyBinaryOperatorOnLists(arguments[0], arguments[1], UniversalNumericOperators.addition);
		}else if(arguments[0].isOfType("Array")){
			return UniversalNumericOperators.applyBinaryOperatorOnListWithObject(arguments[0], arguments[1], UniversalNumericOperators.addition);
		}else if(arguments[1].isOfType("Array")){
			return UniversalNumericOperators.applyBinaryOperatorOnListWithObject(arguments[1], arguments[0], UniversalNumericOperators.addition);
		}
		var args=new List(arguments[0], arguments[1]);
		var argsName=new List(typeOf(arguments[0]), typeOf(arguments[1]));
		var indexes=argsName.sortIndexed();

		args=args.sortOnIndexArray(indexes);
		argsName=argsName.sortOnIndexArray(indexes);
		objectType=argsName.join("_");
		//
		switch(objectType){
			case 'boolean_boolean':
				if( ( args[0] || args[1] ) && !( args[0] && args[1] ) ) {
  					return true;
				}
				return false;
			case 'Point_Point':
				return new Point(args[0].x + args[1].x, args[0].y + args[1].y);
			case 'Point3D_Point3D':
				return new Point3D(args[0].x + args[1].x, args[0].y + args[1].y, args[0].z + args[1].z);
			case 'Point_number':
				return new Point(args[0].x + args[1], args[0].y + args[1]);
			case 'Point3D_number':
				return new Point3D(args[0].x + args[1], args[0].y + args[1], args[0].z + args[1]);
			case 'Interval_number':
				return new Interval(args[0].min + args[1], args[0].max + args[1]);
			case 'Interval_Point':
				return new Point(args[0].min + args[1].x, args[0].max + args[1].y);
			case 'Interval_Interval':
				return new Point(args[0].min + args[1].min, args[0].max + args[1].max);
			case 'Point_Rectangle':
				return new Rectangle(args[0].x + args[1].x, args[0].y + args[1].y, args[1].width, args[1].height);
			case 'Interval_Rectangle':
				return new Rectangle(args[0].min + args[1].x, args[0].max + args[1].y, args[1].width, args[1].height);
			case 'Rectangle_Rectangle':
				return new Rectangle(args[0].x + args[1].x, args[0].y + args[1].y, args[0].width+args[1].width, args[0].height+args[1].height);
			case 'Date_number':
				return new Date(args[0].getTime()+(args[1]*60000));
			case 'Date_Date':
				return new Date(Number(args[0].getTime()+args[1].getTime()));
			case 'Date_DateInterval':
				return new DateInterval(UniversalNumericOperators.addition(args[0], args[1].date0), UniversalNumericOperators.addition(args[0], args[1].date1));
			case 'DateInterval_number':
				return new DateInterval(UniversalNumericOperators.addition(args[0].date0, args[1]), UniversalNumericOperators.addition(args[0].date1, args[1]));
			case 'DateInterval_Interval':
				return new DateInterval(UniversalNumericOperators.addition(args[0].date0, args[1].min), UniversalNumericOperators.addition(args[0].date1, args[1].max));
			case 'DateInterval_DateInterval':
				return new DateInterval(UniversalNumericOperators.addition(args[0].date0, args[1].date0), UniversalNumericOperators.addition(args[0].date1, args[1].date1));
			//perform normal addition:
			case 'boolean_number':
			case 'Date_string':
			case 'number_number':
			case 'number_string':
			case 'string_string':
				break;
			default:
				console.log("[!] addition didn't manage to resolve:", objectType);
				console.log("[!] addition didn't manage to resolve:", objectType, "==", arguments[0]+arguments[1]);
				return null;

		}
		return arguments[0]+arguments[1];
		
		
	}	
		
	result=arguments[0];
	for(i=1; i<arguments.length; i++){
		result=UniversalNumericOperators.addition(result, arguments[i]);
	}
	return result;
}
UniversalNumericOperators.applyBinaryOperatorOnLists=function(list0, list1, operator){
	var n=Math.min(list0.length, list1.length);
	var i;
	var resultList=new List();
	for(i=0; i<n; i++){
		resultList.push(UniversalNumericOperators.applyBinaryOperator(list0[i], list1[i], operator));
	}
	return resultList;
}
UniversalNumericOperators.applyBinaryOperatorOnListWithObject=function(list, object, operator){
	var i;
	var resultList=new List();
	for(i=0; i<list.length; i++){
		resultList.push(UniversalNumericOperators.applyBinaryOperator(list[i], object, operator));
	}
	return resultList;
}
UniversalNumericOperators.applyBinaryOperator=function(object0, object1, operator){
	return operator(object0, object1);
}
UniversalNumericOperators.multiplication=function(){
	var objectType;
	var result;
	var i;
	if(arguments.length<2){
		objectType=typeOf(arguments[0]);
		//console.log(objectType);
		return result;
	}
	if(arguments.length==2){
		if(arguments[0].isOfType("Array") && arguments[1].isOfType("Array")){
			return UniversalNumericOperators.applyBinaryOperatorOnLists(arguments[0], arguments[1], UniversalNumericOperators.multiplication);
		}else if(arguments[0].isOfType("Array")){
			return UniversalNumericOperators.applyBinaryOperatorOnListWithObject(arguments[0], arguments[1], UniversalNumericOperators.multiplication);
		}else if(arguments[1].isOfType("Array")){
			return UniversalNumericOperators.applyBinaryOperatorOnListWithObject(arguments[1], arguments[0], UniversalNumericOperators.multiplication);
		}
		var args=new List(arguments[0], arguments[1]);
		var argsName=new List(typeOf(arguments[0]), typeOf(arguments[1]));
		var indexes=argsName.sortIndexed();
		args=args.sortOnIndexArray(indexes);
		argsName=argsName.sortOnIndexArray(indexes);
		objectType=argsName.join("_");
		//
		switch(objectType){
			case 'boolean_boolean':
				if( args[0] && args[1] ) {
  					return true;
				}
				return false;
			case 'Point_Point':
				return args[0].cross(args[1]);
			case 'Point3D_Point3D':
				return args[0].cross(args[1]);
			case 'Point_number':
				return new Point(args[0].x * args[1], args[0].y * args[1]);
			case 'Point3D_number':
				return new Point3D(args[0].x * args[1], args[0].y * args[1], args[0].z * args[1]);
			case 'Interval_number':
				return new Interval(args[0].min * args[1], args[0].max * args[1]);
			case 'Interval_Point':
				return args[1].cross(new Point(args[0].min, args[0].max));
			case 'Interval_Interval':
				var p=new Point(args[0].min, args[0].max);
				return p.cross(new Point(args[1].min, args[1].max));
	
			case 'Date_number':
				return new Date(args[0].getTime()*(args[1]*60000));
			case 'DateInterval_number':
				return new DateInterval(UniversalNumericOperators.multiplication(args[0].date0, args[1]), UniversalNumericOperators.multiplication(args[0].date1, args[1]));
			case 'DateInterval_Interval':
				return new DateInterval(UniversalNumericOperators.multiplication(args[0].date0, args[1].min), UniversalNumericOperators.multiplication(args[0].date1, args[1].max));
			//perform normal multiplication:
			case 'boolean_number':
			case 'number_number':
				break;
			default:
				console.log("[!] multiplication didn't manage to resolve:", objectType);
				console.log("[!] multiplication didn't manage to resolve:", objectType, "==", arguments[0]*arguments[1]);
				return null;

		}
		return arguments[0]*arguments[1];
		
		
	}	
		
	result=arguments[0];
	for(i=1; i<arguments.length; i++){
		result=UniversalNumericOperators.multiplication(result, arguments[i])
	}
	return result;
}
UniversalNumericOperators.division=function(){
	var objectType;
	var result;
	var i;
	if(arguments.length<2){
		objectType=typeOf(arguments[0]);
		
		console.log(objectType);
		return result;
	}
	if(arguments.length==2){
		objectType=typeOf(arguments[0])+"_"+typeOf(arguments[1]);
		console.log(objectType);
		return arguments[0]/arguments[1];
	}	
		
	result=arguments[0];
	for(i=1; i<arguments.length; i++){
		result=UniversalNumericOperators.division(result, arguments[i])
	}
	return result;
}

UniversalNumericOperators.getMin=function(object){
	var objectType=typeOf(object);
	switch(objectType){
		//case 'DateInterval':
		case 'Interval':
		case 'List':
		case 'NumberList':
		//case 'DateList':
		//case 'NumberTable':
			return object.getMin();
		case 'Point':
			return Math.min(object.x, object.y);
		default:
			console.log("[!] ERROR: UniversalNumericOperators.getMin", object);
			return null;	
	}

}
UniversalNumericOperators.getMax=function(object){
	var objectType=typeOf(object);
	switch(objectType){
		//case 'DateInterval':
		case 'Interval':
		case 'List':
		case 'NumberList':
		//case 'DateList':
		//case 'NumberTable':
			return object.getMax();
		case 'Point':
			return Math.max(object.x, object.y);
		default:
			console.log("[!] ERROR: UniversalNumericOperators.getMax", object);
			return null;	
	}

}
